local move = require "assets.bear.move"
local layering = require "assets.layering"
local defrx=require "defrx.defrx"
local ANIMATION = {
	left_walk = hash("left_walk"),
	right_walk = hash("right_walk"),
	front_walk = hash("front_walk"),
	left_idle = hash("left_idle"),
	right_idle = hash("right_idle"),
	front_idle = hash("front_idle")
}


local MAX_HP=100
local HP_DECREASE_DAYLIGHT=0.167
local HP_DECREASE_DAYLIGHT_ACTION=5
local HP_DECREASE_NIGHT=0.25
local HP_DECREASE_NIGHT_ACTION=10

local TEMPERATURE_DECREASE_DAYLIGHT=0.005
local TEMPERATURE_DECREASE_NIGHT=0.008
local TEMPERATURE_DECREASE_IN_RIVER=0.003
local DEAD_TEMPERATURE=32

local HUNGRY_DECREASE_WAKE=0.167
local HUNGRY_DECREASE_SLEEP=0.083

local MAX_HUNGRY=100




go.property("accel", 100)
go.property("friction", 0.1)
go.property("initial_hp", 100)
go.property("initial_hungry", 100)
go.property("initial_temperature", 36.5)

local function decrease_hungry(self)
	local value
	value = self.hungry.value-HUNGRY_DECREASE_WAKE
	if value <= 0 then
		value=0
	end
	self.hungry:set(value)
end

local function decrease_temperature(self)
	local value
	if self.daylight then
		value = self.temperature.value-TEMPERATURE_DECREASE_DAYLIGHT
	else
		value = self.temperature.value-TEMPERATURE_DECREASE_NIGHT
	end
	if value <= DEAD_TEMPERATURE then
		value=DEAD_TEMPERATURE
	end
	self.temperature:set(value)
end

local function decrease_hp(self)
	local value
	if self.daylight then
		value = self.hp.value-HP_DECREASE_DAYLIGHT
	else
		value = self.hp.value-HP_DECREASE_NIGHT
	end
	if value <= 0 then
		value=0
	end
	self.hp:set(value)
end

local function rive_animation(self)
	if vmath.length(self.vel)<10 then
		if self.current_animation==ANIMATION.left_walk  then
			rive.cancel("#sprite")
			rive.play_anim("#sprite", "left_idle", go.PLAYBACK_LOOP_FORWARD)
			self.current_animation=ANIMATION.left_idle
		elseif self.current_animation==ANIMATION.right_walk then
			rive.cancel("#sprite")
			rive.play_anim("#sprite", "right_idle", go.PLAYBACK_LOOP_FORWARD)
			self.current_animation=ANIMATION.right_idle
		elseif self.current_animation==ANIMATION.front_walk  then
			rive.cancel("#sprite")
			rive.play_anim("#sprite", "front_idle", go.PLAYBACK_LOOP_FORWARD)
			self.current_animation=ANIMATION.front_idle
		end
	elseif self.vel.y<-5 and math.abs(self.vel.x)<20 and self.current_animation~=ANIMATION.front_walk then
		rive.play_anim("#sprite", "front_walk", go.PLAYBACK_LOOP_FORWARD)
		self.current_animation=ANIMATION.front_walk
	elseif self.vel.x>20 and self.current_animation~=ANIMATION.right_walk then
		rive.play_anim("#sprite", "right_walk", go.PLAYBACK_LOOP_FORWARD)
		self.current_animation=ANIMATION.right_walk
	elseif self.vel.x<-20 and self.current_animation~=ANIMATION.left_walk then
		rive.play_anim("#sprite", "left_walk", go.PLAYBACK_LOOP_FORWARD)
		self.current_animation=ANIMATION.left_walk
	elseif self.vel.y>1 then
		if self.current_animation==ANIMATION.right_idle then
			rive.play_anim("#sprite", "right_walk", go.PLAYBACK_LOOP_FORWARD)
			self.current_animation=ANIMATION.right_walk
		elseif self.current_animation~=ANIMATION.left_walk and self.current_animation~=ANIMATION.right_walk then
			rive.play_anim("#sprite", "left_walk", go.PLAYBACK_LOOP_FORWARD)
			self.current_animation=ANIMATION.left_walk
		end
	end
end

function init(self)
	print(go.get_id())
	self.daylight=true
	rive.play_anim("#sprite", "front_idle", go.PLAYBACK_LOOP_FORWARD)
	self.current_animation=ANIMATION.front_idle
	--move
	msg.post(".", "acquire_input_focus")
	move.init(self)

	--reactive property
	self.temperature =  defrx.create_reactive_property(self.initial_temperature, "temperature")
	self.hungry = defrx.create_reactive_property(self.initial_hungry, "hungry")
	self.hp = defrx.create_reactive_property(self.initial_hp, "hp")
	
	--stream
	defrx.create_stream("minute")
	defrx.observe(self, "minute", function(self, message_id, message)
		decrease_hungry(self)
		decrease_temperature(self)
		decrease_hp(self)
	end)

	defrx.create_stream("daylight")
	defrx.observe(self, "daylight", function(self, message_id, message)
		self.daylight = message.value
	end)
end

function update(self, dt)
	move.update(self, dt)
	rive_animation(self)
	layering.update(self)
	defrx.notify("bear_update", {position=go.get_position()})
end

function on_message(self, message_id, message, sender)
	
	defrx.on_message(self, message_id, message, sender)
	if message_id==hash("contact_point_response") and message.other_group ==hash("obstacle") then
		go.set_position(go.get_position()+message.distance*message.normal)
	end
	if message_id==hash("collision_response") and message.own_group == hash("bear") then
		if self.interact_target  then
			local last_distance = vmath.length(go.get_position(self.interact_target)-go.get_position()) 
			local current_distance = vmath.length(message.other_position-go.get_position()) 
			if current_distance < last_distance then
				msg.post(self.interact_target, "target_released")
				msg.post(message.other_id, "check_interactable")
				self.interact_target=message.other_id
			end
		else
			msg.post(message.other_id, "check_interactable")
			self.interact_target=message.other_id
		end
	end
	if message_id==hash("release_target") then
		self.interact_target=nil
	end
end

function final(self)
	defrx.cancel_all_observing(self)
end

function on_input(self, action_id, action)
	move.on_input(self, action_id, action)
end
